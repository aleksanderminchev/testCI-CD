from api.app import db
from api.utils.views import create_mat_view, MaterializedView
from models.subjects import Subjects
from models.teacher import Teacher, Program, Interest, Qualification, Language, HigherEducationProgramme, HigherEducationInstitution

query_string = db.select([Teacher.id.label('id'),
                         HigherEducationInstitution.id.label('higher_education_institution_id'), HigherEducationProgramme.id.label(
                             'higher_education_programme_id'), Interest.uid.label('interest_id'), Qualification.uid.label('qualification_id'),
                          Language.uid.label('language_id'), Subjects.uid.label('subject_id'), Program.uid.label('program_id')]
                         ).join(Teacher.higher_education_institutions).join(Teacher.higher_education_programmes
                                                                            ).join(Teacher.subjects
                                                                                   ).join(Teacher.qualifications).join(Teacher.languages).join(Teacher.interests).join(Teacher.programs)


class TeacherView(MaterializedView):
    """View that will be used for filtering the teachers
    Its a materialized view that will get used often and updated every couple of days
    In a migration file add the following code to create the view:
    Use this code to create the view:
    from models.teacher_view import query_string
    from sqlalchemy.dialects import postgresql
    def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    view_query_string= str(query_string.compile(compile_kwargs={"literal_binds": True}))
    print(view_query_string)
    op.execute(f"CREATE VIEW teacher_view AS {view_query_string}")
    # ### end Alembic commands ###


    def downgrade():
        # ### commands auto generated by Alembic - please adjust! ###

        op.execute('DROP VIEW teacher_view')
        # ### end Alembic commands ###

    """
    __table__ = create_mat_view('teacher_view', query_string)

    @staticmethod
    def convert(teacher_view_array):
        # takes a TeacherView array
        # generate query Teachers and generate a set
        # then return the set of teachers which will get appended
        # make the other lists into sets then merge since we don't want duplicates
        teacher_set = {Teacher.query.get(i.id)
                       for i in teacher_view_array or []}
        print(teacher_set)
        return teacher_set

    # @classmethod
    # def refresh(cls, concurrently=True):
    #    refresh_materialized_view(cls.__table__.fullname, concurrently)


db.Index('activity_view_index',
         TeacherView.__table__.c.id,
         unique=True)
